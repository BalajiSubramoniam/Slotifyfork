# app/models/washingmachine.py
# 
# Author: Indrajit Ghosh
# Created On: May 10, 2025
# 
import uuid
from datetime import datetime

from scripts.utils import utcnow
from flask import url_for

from app.extensions import db
from app.models.booking import TimeSlot

class WashingMachine(db.Model):
    __tablename__ = 'washingmachine'

    id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: uuid.uuid4().hex)
    name = db.Column(db.String(100), unique=True, nullable=False)
    code = db.Column(db.String(50), unique=True, nullable=False)
    status = db.Column(db.String(20), nullable=False, default="available") # e.g., "available", "maintenance", "offline"

    # Store images in app/main/static/uploads/machines/
    image_path = db.Column(db.String(255), nullable=True)

    created_at = db.Column(db.DateTime(timezone=True), default=utcnow)
    last_updated = db.Column(db.DateTime(timezone=True), default=utcnow)

    building_id = db.Column(db.Integer, db.ForeignKey('building.id'), nullable=False)
    building = db.relationship("Building", back_populates="machines")

    time_slots = db.relationship("TimeSlot", back_populates="machine", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<WashingMachine(name={self.name}, code={self.code})>"
    
    def is_available(self):
        return self.status.lower() == 'available'
    
    def get_image_url(self):
        # If full URL (e.g., from S3), return it directly
        if self.image_path.startswith("http"):
            return self.image_path
        # Otherwise return relative static path
        return url_for("static", filename=self.image_path, _external=True)
    
    def to_json(self):
        """
        Serialize the washing machine to a JSON-compatible dict.
        """
        return {
            "uuid": self.uuid,
            "name": self.name,
            "code": self.code,
            "status": self.status,
            "image_path": self.image_path,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_updated": self.last_updated.isoformat() if self.last_updated else None,
            "building_uuid": self.building.uuid if self.building else None,
            "time_slots": [slot.to_json() for slot in self.time_slots]
        }
    
    @classmethod
    def from_json(cls, data, building_lookup):
        """
        Create a WashingMachine instance from a JSON dictionary.
    
        This method reconstructs a WashingMachine ORM object from its JSON representation,
        including its relationship to a Building instance and associated TimeSlots.
    
        Args:
            data (dict): JSON dictionary typically generated by the `to_json()` method,
                         representing the washing machine and its related fields.
            building_lookup (dict): A dictionary mapping building UUID strings to Building model instances.
                                    This is required to resolve the foreign key relationship because
                                    the JSON only stores the building's UUID, not the full ORM object.
    
                                    Example:
                                        {
                                            "building-uuid-1": <Building instance 1>,
                                            "building-uuid-2": <Building instance 2>,
                                            ...
                                        }
    
        Returns:
            WashingMachine: A new WashingMachine instance with its attributes populated from `data`,
                            including a valid Building instance from `building_lookup` and a list
                            of TimeSlot objects from the nested JSON.
    
        Raises:
            ValueError: If the building UUID in `data` is not found in `building_lookup`. This prevents
                        creating a WashingMachine with a missing or invalid building reference,
                        ensuring referential integrity during import.
    
        Usage:
            Before calling this method, prepare `building_lookup` by loading all relevant Building instances:
                all_buildings = Building.query.all()
                building_lookup = {b.uuid: b for b in all_buildings}
    
            Then import:
                wm = WashingMachine.from_json(json_data, building_lookup)
    
        """
        def parse_dt(key):
            val = data.get(key)
            return datetime.fromisoformat(val) if val else None
        
        building = building_lookup.get(data["building_uuid"])
        if not building:
            raise ValueError(f"Building with UUID {data['building_uuid']} not found for WashingMachine import")

        wm = cls(
            uuid=data["uuid"],
            name=data["name"],
            code=data["code"],
            status=data.get("status", "available"),
            image_path=data.get("image_path"),
            created_at=parse_dt("created_at"),
            last_updated=parse_dt("last_updated"),
            building=building
        )
        # wm.time_slots = [TimeSlot.from_json(ts) for ts in data.get("time_slots", [])]
        return wm
