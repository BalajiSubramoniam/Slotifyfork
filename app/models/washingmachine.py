# app/models/washingmachine.py
# 
# Author: Indrajit Ghosh
# Created On: May 10, 2025
# 
import uuid
from datetime import datetime

from scripts.utils import utcnow
from flask import url_for

from app.extensions import db

class WashingMachine(db.Model):
    __tablename__ = 'washingmachine'

    id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: uuid.uuid4().hex)
    name = db.Column(db.String(100), unique=True, nullable=False)
    code = db.Column(db.String(50), unique=True, nullable=False)
    status = db.Column(db.String(20), nullable=False, default="available") # e.g., "available", "maintenance", "offline"

    # Store images in app/main/static/uploads/machines/
    image_path = db.Column(db.String(255), nullable=True)

    # External image URL (e.g., Google Drive, Dropbox)
    image_url = db.Column(db.String(512), nullable=True)

    created_at = db.Column(db.DateTime(timezone=True), default=utcnow)
    last_updated = db.Column(db.DateTime(timezone=True), default=utcnow)

    building_id = db.Column(db.Integer, db.ForeignKey('building.id'), nullable=False)
    building = db.relationship("Building", back_populates="machines")

    time_slots = db.relationship("TimeSlot", back_populates="machine", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<WashingMachine(name={self.name}, code={self.code})>"
    
    def is_available(self):
        return self.status.lower() == 'available'
    
    def get_image_url(self):
        """
        Return the appropriate image URL: external if provided, otherwise local.
        """
        if self.image_url:
            return self.image_url
        elif self.image_path:
            return url_for("static", filename=self.image_path, _external=True)
        return None
    
    
    def to_json(self):
        return {
            "uuid": self.uuid,
            "name": self.name,
            "code": self.code,
            "status": self.status,
            "image_path": self.image_path,
            "image_url": self.image_url,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_updated": self.last_updated.isoformat() if self.last_updated else None,
            "building_uuid": self.building.uuid if self.building else None,
            "time_slots": [slot.to_json() for slot in self.time_slots]
        }  
      
    @classmethod
    def from_json(cls, data, building_lookup):
        """
        Create a WashingMachine instance from a JSON dictionary.
    
        This method reconstructs a WashingMachine ORM object from its JSON representation,
        including its relationship to a Building instance and associated TimeSlots.
    
        Args:
            data (dict): JSON dictionary typically generated by the `to_json()` method,
                         representing the washing machine and its related fields.
            building_lookup (dict): A dictionary mapping building UUID strings to Building model instances.
                                    This is required to resolve the foreign key relationship because
                                    the JSON only stores the building's UUID, not the full ORM object.
    
                                    Example:
                                        {
                                            "building-uuid-1": <Building instance 1>,
                                            "building-uuid-2": <Building instance 2>,
                                            ...
                                        }
    
        Returns:
            WashingMachine: A new WashingMachine instance with its attributes populated from `data`,
                            including a valid Building instance from `building_lookup` and a list
                            of TimeSlot objects from the nested JSON.
    
        Raises:
            ValueError: If the building UUID in `data` is not found in `building_lookup`. This prevents
                        creating a WashingMachine with a missing or invalid building reference,
                        ensuring referential integrity during import.
    
        Usage:
            Before calling this method, prepare `building_lookup` by loading all relevant Building instances:
                all_buildings = Building.query.all()
                building_lookup = {b.uuid: b for b in all_buildings}
    
            Then import:
                wm = WashingMachine.from_json(json_data, building_lookup)
    
        """
        def parse_dt(key):
            val = data.get(key)
            return datetime.fromisoformat(val) if val else None
        
        building = building_lookup.get(data["building_uuid"])
        if not building:
            raise ValueError(f"Building with UUID {data['building_uuid']} not found for WashingMachine import")

        wm = cls(
            uuid=data["uuid"],
            name=data["name"],
            code=data["code"],
            status=data.get("status", "available"),
            image_path=data.get("image_path"),
            image_url=data.get("image_url"),
            created_at=parse_dt("created_at"),
            last_updated=parse_dt("last_updated"),
            building=building
        )
        return wm
